/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tpw.homeshell;

import com.tpw.homeshell.vpinstall.VPUtils.VPInstallStatus;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.AnimatorSet;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Canvas;
import android.graphics.Point;
import android.graphics.Bitmap;
import android.graphics.ColorFilter;
import android.graphics.LinearGradient;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.support.v4.view.ViewPager.SimpleOnPageChangeListener;
import android.text.Editable;
import android.text.InputType;
import android.text.Selection;
import android.text.TextWatcher;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.LinearInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import com.tpw.homeshell.Alarm.OnAlarmListener;
import com.tpw.homeshell.AppDownloadManager.AppDownloadStatus;
import com.tpw.homeshell.FolderInfo.FolderListener;
import com.tpw.homeshell.LauncherSettings.Favorites;
import com.tpw.homeshell.icon.BubbleTextView;
import com.tpw.homeshell.icon.IconManager;
import com.tpw.homeshell.model.LauncherModel;
import com.tpw.homeshell.setting.HomeShellSetting;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import com.tpw.homeshell.utils.Utils;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource, View.OnClickListener,
        View.OnLongClickListener, DropTarget, FolderListener, TextView.OnEditorActionListener, DragScroller,
        View.OnFocusChangeListener {
    private static final String TAG = "Launcher.Folder";

    protected DragController mDragController;
    protected Launcher mLauncher;
    protected FolderInfo mInfo;

    public static final int STATE_NONE = -1;
    public static final int STATE_SMALL = 0;
    public static final int STATE_ANIMATING = 1;
    public static final int STATE_OPEN = 2;
    private final int MAX_ITEMS_COUNT = 1000;

    private int mExpandDuration;
    private CellLayout mContent;
    private /*topwise zyf delete final*/ LayoutInflater mInflater;
    private volatile int mState = STATE_NONE;
    private static final int REORDER_ANIMATION_DURATION = 230;

    private static final int ON_EXIT_CLOSE_DELAY = 100;

    private boolean mRearrangeOnClose = false;
    private FolderIcon mFolderIcon;
    private int mMaxCountX;
    private int mMaxCountY;
    private int mMaxItemsCountPerPage;
    private int mMaxNumItems;
    private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
    private Drawable mIconDrawable;
    boolean mItemsInvalidated = false;
    private ShortcutInfo mCurrentDragInfo;
    private View mCurrentDragView;
    boolean mSuppressOnAdd = false;
    private int[] mTargetCell = new int[2];
    private int[] mPreviousTargetCell = new int[2];
    private int[] mEmptyCell = new int[2];
    private Alarm mReorderAlarm = new Alarm();
    private Alarm mOnExitAlarm = new Alarm();
    private int mFolderNameHeight;
    private int mFolderNameContentGap;
    private Rect mTempRect = new Rect();
    private boolean mDragInProgress = false;
    private boolean mDeleteFolderOnDropCompleted = false;
    private boolean mSuppressFolderDeletion = false;
    private boolean mItemAddedBackToSelfViaIcon = false;
    FolderEditText mFolderName;
    private float mFolderIconPivotX;
    private float mFolderIconPivotY;
    private FolderAppsSelectView mAppsSelectView;
    private AnimatorSet mRunningAnimatorSet = null;
    private boolean mRunningIsShow = false;

    private boolean mIsEditingName = false;
    private InputMethodManager mInputMethodManager;

    private static String sDefaultFolderName;
    // private static String sHintText;
    private Animator mOpenCloseAnimator;

    private boolean mDestroyed;
    private View mEditFolderTempView;
    private boolean mEditFolderHidden = false;
    // true : drop accepted ; false : drop rejected
    private boolean mDropAccepted = false;
    protected ShortcutInfo mShortcutInfoCache = null;
    protected boolean mHasDirtyData = false;
    private int mAnimatorDuration = 300;
    private ArrayList<CellLayout> mContentList = new ArrayList<CellLayout>();
    private FolderSelectPager mFolderViewPager;
    private PagerAdapter mContentAdapter;
    private PageIndicatorView mPageIndicator;
    private boolean mDragExit = false;
    private boolean mScrolling = false;
    private int mLastOrientation;

    /**
     * used for get the screen's width and height
     */
    private Point mDisplaySize = new Point();

    // Enables dragging icon out of folder through left and right edge.
    // Reset in onDragEnter() and modified in scrollLeft() and scrollRight().
    private boolean mDraggingToLeftEdge = false;
    private boolean mDraggingToRightEdge = false;

    /**
     * Used to inflate the Workspace from XML.
     *
     * @param context The application's context.
     * @param attrs The attribtues set containing the Workspace's customization values.
     */
    public Folder(Context context, AttributeSet attrs) {
        super(context, attrs);
        setAlwaysDrawnWithCacheEnabled(false);
        mInflater = LayoutInflater.from(context);

/*
        Resources res = getResources();
        mMaxCountX = res.getInteger(R.integer.folder_max_count_x);
        mMaxCountY = res.getInteger(R.integer.folder_max_count_y);
        mMaxNumItems = res.getInteger(R.integer.folder_max_num_items);
        if (mMaxCountX < 0 || mMaxCountY < 0 || mMaxNumItems < 0) {
            mMaxCountX = LauncherModel.getCellCountX();
            mMaxCountY = LauncherModel.getCellCountY();
            mMaxNumItems = mMaxCountX * mMaxCountY;
        }
*/
        mLauncher = (Launcher) context;
        mIconManager = mLauncher.getIconManager();
        mMaxCountX = ConfigManager.getFolderMaxCountX();
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        mMaxNumItems = mMaxCountX * mMaxCountY;

        Resources res = getResources();
        mInputMethodManager = (InputMethodManager)
                getContext().getSystemService(Context.INPUT_METHOD_SERVICE);

        mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

        if (sDefaultFolderName == null) {
            sDefaultFolderName = res.getString(R.string.folder_name);
        }
        /*
         * if (sHintText == null) { sHintText =
         * res.getString(R.string.folder_hint_text); }
         */
        // We need this view to be focusable in touch mode so that when text editing of the folder
        // name is complete, we have something to focus on, thus hiding the cursor and giving
        // reliable behvior when clicking the text field (since it will always gain focus on click).
        setFocusableInTouchMode(true);
        
        mShortcutInfoCache = new ShortcutInfo();
        
        Display display = mLauncher.getWindowManager().getDefaultDisplay();
        display.getSize(mDisplaySize);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        setContent((CellLayout) findViewById(R.id.folder_content));
        mContent.setGridSize(0, 0);
        mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        mContent.setInvertIfRtl(true);
        mContentList.add(mContent);
        mFolderName = (FolderEditText) findViewById(R.id.folder_name);
        mFolderName.setFolder(this);
        mFolderName.setOnFocusChangeListener(this);
        mContentAdapter = new FolderContentAdapter();
        mFolderViewPager = (FolderSelectPager) findViewById(R.id.folder_view_pager);
        mFolderViewPager.setOffscreenPageLimit(40);
        mFolderViewPager.setAdapter(mContentAdapter);
        mFolderViewPager.setOnPageChangeListener(pageChangeListener);
        mFolderViewPager.setOnClickListener(this);
        mPageIndicator = (PageIndicatorView) findViewById(R.id.folder_page_indicator);
        mPageIndicator.setNeedLine(false);
        // We find out how tall the text view wants to be (it is set to wrap_content), so that
        // we can allocate the appropriate amount of space for it.
        int measureSpec = MeasureSpec.UNSPECIFIED;
        mFolderName.measure(measureSpec, measureSpec);
        //folder name show wrong, when the system font is super big
        mFolderNameHeight = mFolderName.getMeasuredHeight();
 
        mFolderNameContentGap = getResources().getDimensionPixelSize(R.dimen.folder_name_content_gap);
        // We disable action mode for now since it messes up the view on phones
        mFolderName.setOnEditorActionListener(this);
        mFolderName.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
            }
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }
            @Override
            public void afterTextChanged(Editable s) {
                mFolderName.requestLayout();
            }
        });
        mFolderName.setSelectAllOnFocus(true);
        mFolderName.setInputType(mFolderName.getInputType() |
                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        showFolderNameOutline(false);
        updateFolderLayout(mIconManager.supprtCardIcon());
        mLastOrientation = getResources().getConfiguration().orientation;
    }

    @Override
    protected void onAttachedToWindow() {
        updateOrientation();
        mContent = mContentList.get(0);
        mContent.setLayerType(LAYER_TYPE_NONE, null);
        super.onAttachedToWindow();
        mLauncher.getDragController().setDragScoller(this);
        mLauncher.getDragController().setScrollView(mFolderViewPager);
        mDragExit = false;
    }

    @Override
    protected void onDetachedFromWindow() {
        super.onDetachedFromWindow();
        mIsEditingName = false;
        mLauncher.getDragController().setDragScoller(mLauncher.getWorkspace());
        mLauncher.getDragController().setScrollView(mLauncher.getDragLayer());
    }

    private void updateFolderLayout(boolean supportCardIcon){
        final int w, h, wg, hg, l, t, r, b, countX, countY;
        Resources res = getResources();
        if (supportCardIcon) {
            if (AgedModeUtil.isAgedMode()) {
                w = res.getDimensionPixelSize(R.dimen.bubble_icon_width_3_3);
                h = res.getDimensionPixelSize(R.dimen.bubble_icon_height_3_3);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = (int) (res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_3_3) * 0.5);
                l = res.getDimensionPixelSize(R.dimen.folder_cell_layout_start_padding_3_3);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                r = res.getDimensionPixelSize(R.dimen.folder_cell_layout_end_padding_3_3);
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding_3_3);
            } else {
                w = res.getDimensionPixelSize(R.dimen.folder_cell_width);
                h = res.getDimensionPixelSize(R.dimen.folder_cell_height);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap);
                l = mContent.getPaddingLeft();
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding);
                r = mContent.getPaddingRight();
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding);
            }
            countX = mMaxCountX;
        } else {
            if (AgedModeUtil.isAgedMode()) {
                w = res.getDimensionPixelSize(R.dimen.bubble_icon_width_3_3);
                h = res.getDimensionPixelSize(R.dimen.bubble_icon_height_3_3);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small_3_3);
                l = res.getDimensionPixelSize(R.dimen.folder_cell_layout_start_padding_3_3);
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                r = res.getDimensionPixelSize(R.dimen.folder_cell_layout_end_padding_3_3);
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding_3_3);
            } else {
                w = res.getDimensionPixelSize(R.dimen.folder_cell_width_small);
                h = res.getDimensionPixelSize(R.dimen.folder_cell_height_small);
                wg = res.getDimensionPixelSize(R.dimen.folder_cell_width_gap_small);
                hg = res.getDimensionPixelSize(R.dimen.folder_cell_height_gap_small);
                l = mContent.getPaddingLeft();
                t = res.getDimensionPixelSize(R.dimen.folder_cell_layout_top_padding_small);
                r = mContent.getPaddingRight();
                b = res.getDimensionPixelSize(R.dimen.folder_cell_layout_bottom_padding);
            }
            countX = mMaxCountX;
        }
        countY = ConfigManager.getFolderMaxCountY();
        mContentWidth = countX * w + (countX - 1) * wg + l + r;
        mContentHeight = countY * h + (countY - 1) * hg + t + b;
        for (CellLayout mContent : mContentList) {
            mContent.setCellSize(w, h, wg, hg, true);
            mContent.setPadding(l, t, r, b);
        }
    }

    float mIconScale, mIconPaddingX, mIconPaddingY;
    boolean mSupportCardIcon, mSinglePage, mHotSeat;
    int mIconChild, mContentHeight, mContentWidth, mDrawingLimit, mPageCount, mLastDesireWidth;
    IconManager mIconManager;

    void drawFolderIcon(Canvas c, int w, int h, float padding, float contentPadding, boolean hotSeat) {
        CellLayout mContent = mContentList.get(0);
        boolean supportCard = isSupportCardIcon();
        int count = mContent.getShortcutAndWidgetContainer().getChildCount();
        int desireWidth = mContent.getDesiredWidth();
        if (mSupportCardIcon != supportCard && !Launcher.sReloadingForThemeChangeg) {
            updateFolderLayout(supportCard);
            mSupportCardIcon = supportCard;
        }
        updateOrientation();
        int countX = mContent.getCountX();
        int cellWidth = mContent.getCellWidth();
        int cellHeight = mContent.getCellHeight();
        int widthGap = mContent.getWidthGap();
        int heightGap= mContent.getHeightGap();
        int topPadding = mContent.getPaddingTop();
        int startPadding = mContent.getPaddingStart();
        mHotSeat = hotSeat;
        mIconChild = count;
        mLastDesireWidth = desireWidth;
        int contentWidth = mContent.getDesiredWidth();
        float iconScale;
        if (mSupportCardIcon) {
            if (!AgedModeUtil.isAgedMode()) {
                iconScale = (float) w / contentWidth;
                padding = (int) (startPadding * iconScale);
                mIconPaddingX = contentPadding;
            } else {
                iconScale = (w - 2 * contentPadding) / contentWidth;
                mIconPaddingX = contentPadding;
            }
            if (!hotSeat)
                mIconPaddingY = contentPadding - iconScale * getFolderNamePadding();
        } else {
            iconScale = (float) (w - padding * 2) /  (contentWidth - startPadding * 2);
            float div = (cellHeight * countX + heightGap * (countX - 1) - cellWidth * countX + widthGap * (countX - 1)) / 2 * iconScale * 0.2f;
            if (AgedModeUtil.isAgedMode()) {
                c.translate(div, 0);
            } else {
                c.translate(div, div);
            }
            mIconPaddingX = contentPadding - iconScale * startPadding;
            if(!hotSeat)
                mIconPaddingY = contentPadding - div - iconScale * (getFolderNamePadding() + topPadding);
        }
        if(hotSeat)
            mIconPaddingY = BubbleTextView.sTopPaddingHotseat - iconScale * getFolderNamePadding();
        mIconScale = iconScale; 

        if (mSupportCardIcon) {
            if (AgedModeUtil.isAgedMode()) {
                c.translate(contentPadding, contentPadding);
            }
            c.clipRect(0, 0, w, h);
        } else
            c.clipRect(0, 0, w - padding * 2, h - padding);

        c.scale(iconScale, iconScale);
        int iconH = (int) (h / iconScale);

        int countY = (iconH - topPadding + heightGap) / (cellHeight + heightGap);
        ArrayList<View> icons = getItemsInReadingOrder(false);
        if (mSupportCardIcon)
            c.translate(startPadding, topPadding);
        if (mFolderIcon.mHideIcon)
            return;
        boolean rtl = getResources().getConfiguration().getLayoutDirection() == LAYOUT_DIRECTION_RTL;
        mPageCount = countX * (mSupportCardIcon ? countX : countX + 1);
        mDrawingLimit = Math.min(icons.size(), countX * countY);

        for (int i = 0, N = mDrawingLimit; i < N; i++) {
            int x = (rtl ? (countX - (i % countX) - 1) : (i % countX)) * (cellWidth + widthGap);
            int y = (i / countX) * (cellHeight + heightGap);

            int widthInFolderIcon = w;
            int heightInFolderIcon = h;
            if (supportCard) {
                // The w & h are the width & height of folderIcon. If draw in hotseat use w & h and in BigCard model,
                // will draw little bubbletextviews which in folder to be square, not rectangle which is we real need.
                // so in BigCard model, we need to use the cellWidth an cellHeight which are get form the CellLayout.
                // but in little card model, we can't use the cellWidth and cellHeight, because cellWidth and cellHeight is
                // big than w and h.
                widthInFolderIcon = cellWidth;
                heightInFolderIcon = cellHeight;
            }

            c.save();
            c.translate(x, y);
            ((BubbleTextView) icons.get(i)).drawBubbleTextViewInFolderIcon(widthInFolderIcon, heightInFolderIcon, c);
            c.restore();
        }
    }

    private void updateOrientation() {
        updateOrientation(getResources().getConfiguration().orientation);
    }

    private void updateOrientation(int orientation) {
        if (mLastOrientation != orientation) {
            for (CellLayout layout : mContentList) {
                layout.onConfigurationChanged(getResources().getConfiguration());
                layout.forceLayout();
            }
            updateFolderLayout(mSupportCardIcon);
            requestLayout();
            mLastOrientation = orientation;
        }
    }

    @Override
    protected void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        updateOrientation(newConfig.orientation);
    }

    float getLocalCenterForIndex(int index, float[] center, int width, boolean extended) {
        float scale = mIconScale;
        if (scale == 0)
            scale = (float) width / mContent.getDesiredWidth();
        int countX = mContent.getCountX();
        int cellWidth = mContent.getCellWidth();
        int cellHeight = mContent.getCellHeight();
        int widthGap = mContent.getWidthGap();
        int heightGap = mContent.getHeightGap();
        int topPadding = mContent.getPaddingTop();
        int leftPadding = mContent.getPaddingLeft();
        int x = index % countX;
        int y = index / countX;
        if(extended)
            x = y = countX / 2;
        else if(getResources().getConfiguration().getLayoutDirection() == LAYOUT_DIRECTION_RTL)
            x = countX - x - 1;
        int centerX = x * (cellWidth + widthGap) + cellWidth / 2 + leftPadding;
        int centerY = y * (cellHeight + heightGap) + cellHeight / 2 + topPadding;
        int margin = mSupportCardIcon && !mHotSeat ? 0 : (width - FolderIcon.mPreiewSize) / 2;
        center[0] = scale * centerX + margin;
        center[1] = scale * centerY + margin;
        return scale;
    }

    public boolean isSupportCardIcon() {
        return mIconManager.supprtCardIcon();
    }

    public int getFolderNamePadding() {
        return mFolderNameHeight + mFolderNameContentGap;
    }

    public FolderIcon getFolderIcon() {
        return mFolderIcon;
    }

    public void scrollUp() {
    }
    public void scrollDown() {
    }
    public void scrollLeft() {
        if (mDragExit)
            return;
        int current = mFolderViewPager.getCurrentItem();
        if (current > 0) {
            this.switchToPage(current - 1);
            this.autoMoveIconByScroll(current, current - 1);
        } else {
            mDraggingToLeftEdge = true;
        }
    }
    public void scrollRight() {
        if (mDragExit)
            return;
        int current = mFolderViewPager.getCurrentItem();
        int count = mFolderViewPager.getAdapter().getCount();
        if(current < count - 1) {
            this.switchToPage(current + 1);
            this.autoMoveIconByScroll(current, current + 1);
        } else {
            mDraggingToRightEdge = true;
        }
    }
    public boolean onEnterScrollArea(int x, int y, int direction) {
        return true;
    }
    public boolean onExitScrollArea() {
        return false;
    }

    public void onClick(View v) {
        // close folder on click
        if(v == mFolderViewPager && !mLauncher.isGadgetCardShowing()) {
            mLauncher.closeFolder();
            return;
        }
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            // refactor this code from Folder
            ShortcutInfo item = (ShortcutInfo) tag;
            if(item.isEditFolderShortcut()) {
                int[] position = new int[]{0,0};
                v.getLocationOnScreen(position);
                position[0] += ((BubbleTextView)v).getBUBBLE_WIDTH()/2;
                position[1] +=((BubbleTextView)v).getBUBBLE_HEIGHT()/2;
                showSelectApps(position);
            } else {
                item.setIsNewItem(false);
                ((BubbleTextView)v).updateView(item);
                mLauncher.getModel().modifyItemNewStatusInDatabase(getContext(), item, false);
                mFolderIcon.invalidate();
                int[] pos = new int[2];
                v.getLocationOnScreen(pos);
                item.intent.setSourceBounds(new Rect(pos[0], pos[1],
                        pos[0] + v.getWidth(), pos[1] + v.getHeight()));

                if (item.itemType == LauncherSettings.Favorites.ITEM_TYPE_VPINSTALL) {
                    mLauncher.getModel().startVPSilentInstall(item);
                }
                else if(item.isDownloading()/*zyf add */&&!(isOnlineShortcutInfo(item.intent))){
                	Log.d("zyfonline","onClick : isDownloading!!!");
                    mLauncher.onDownloadingClick(v);
                }else{
                	 //topwise zyf add for exapp
                    Intent intent=item.intent;
                    if(intent.getAction()!=null&&intent.getAction().equals("com.tpw.install"))
                    {
                    	item.messageNum=0;
                    	//检查是否已安装
                    	String pkgname=intent.getStringExtra(com.tpw.homeshell.vpinstall.VPUtils.TYPE_PACKAGENAME)==null?intent.getComponent().getPackageName():
                    		intent.getStringExtra(com.tpw.homeshell.vpinstall.VPUtils.TYPE_PACKAGENAME);
                    	String apkpath=intent.getStringExtra(com.tpw.homeshell.vpinstall.VPUtils.TYPE_PACKAGEPATH);
                    	if(pkgname!=null)
                    	{
                    		if(Utilities.isApkInstalled(pkgname,getContext()))
                    		{
                    			Intent intenttemp=Utilities.getApkInent(pkgname,this.getContext());
                    			if(intenttemp!=null)
                    			{
                    				item.intent=intenttemp;
                    				if (item.getVPInstallStatus() != VPInstallStatus.STATUS_NORMAL)
                    				{
                    					item.setVPInstallStatus(VPInstallStatus.STATUS_NORMAL);
                    				}
                    					mLauncher.startActivitySafely(v, item.intent, item);
											//刷新图标
											final ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
											items.add(item);
											mLauncher.getModel().notifyUIUpdateIcon(items);
                    			}
                    		}
                    		else {
        						//需要安装
                    			if (item.getVPInstallStatus() == VPInstallStatus.STATUS_NORMAL)
                    			{
                    				item.setAppDownloadStatus(AppDownloadStatus.STATUS_INSTALLING);
                    				mLauncher.getModel().startVPSilentInstall(item);
                    			}
        					}
                    		if (item.itemType == LauncherSettings.BaseLauncherColumns.ITEM_TYPE_APPLICATION) {
                                ((LauncherApplication)mLauncher.getApplicationContext())
                                    .collectUsageData(item.id);
                          }
                    	}
                    	
                    }
                    //topwise zyf add for folderonline
                    else if(intent.getAction()!=null&&intent.getAction().equals("com.tpw.online"))
                    {
                    	item.messageNum=0;
                    	//检查是否已安装
                    	String pkgname=intent.getStringExtra(ExappUtil.PACKAGENAME)==null?
                    			intent.getComponent().getPackageName():
                    			intent.getStringExtra(ExappUtil.PACKAGENAME);
                    			
                    	String fullpath=intent.getStringExtra(ExappUtil.SAVE_PATH);
                    			
                    	if(pkgname!=null)
                    	{
                    		if(Utilities.isApkInstalled(pkgname,getContext()))
                    		{
                    			Intent intenttemp=Utilities.getApkInent(pkgname,this.getContext());
                    			if(intenttemp!=null)
                    			{
                    				item.intent=intenttemp;
                    				if (item.getVPInstallStatus() != VPInstallStatus.STATUS_NORMAL)
                    				{
                    					item.setVPInstallStatus(VPInstallStatus.STATUS_NORMAL);
                    				}
                    				mLauncher.startActivitySafely(v, item.intent, item);
                    			}
                    		}
                    		else 
                    		{
                        		//检查是否已经下载完成
                        	 if(ExappUtil.isFileExists(fullpath))
                        		{
                        		  Intent noinstallIntent=new Intent("com.tpw.install");
                      			  noinstallIntent.putExtra(com.tpw.homeshell.vpinstall.VPUtils.TYPE_PACKAGEPATH,fullpath);
                      			  noinstallIntent.putExtra(com.tpw.homeshell.vpinstall.VPUtils.TYPE_PACKAGENAME,pkgname);
                      			  item.intent =noinstallIntent;
                    			  mLauncher.getModel().startVPSilentInstall(item);
                        		}
                        	 else
	                        	 {
	        						//需要下载并安装
                        		 	 Log.d("zyfonline","onClick : need to download!!!");
                        		 	 
                        		 	 int state=item.getAppDownloadStatus();
                        		 	if(state == AppDownloadStatus.STATUS_DOWNLOADING||state==AppDownloadStatus.STATUS_WAITING)
                        		 	{
                        		 		String url=intent.getStringExtra(ExappUtil.DOWNLOAD_URL);
                        		 		//正在下载,则暂停
                        		 		Intent intent_download=new Intent(ExappUtil.ACTION_TPW_DOWNLOAD_TO_PAUSE);
		                    			intent_download.putExtra(ExappUtil.EXTAR_SAVE_FILEPATH,fullpath);
		                    			intent_download.putExtra(ExappUtil.EXTRA_DOWNLOAD_URL, url);
		                    			intent_download.putExtra(ExappUtil.EXTAR_IS_PAUSE_BY_USER, true);
		                    			mLauncher.sendBroadcast(intent_download);
		                    			item.setAppDownloadStatus(AppDownloadStatus.STATUS_PAUSED);
                        		 	}
                        		 	else if(state==AppDownloadStatus.STATUS_NO_DOWNLOAD
                        		 			||state==AppDownloadStatus.STATUS_PAUSED
                        		 			)
                        		 	{
		                        		 Intent intent_notify=new Intent(AppDownloadManager.ACTION_ONLINE_DOWNLOAD_TASK);
		                        		 intent_notify.putExtra(AppDownloadManager.TYPE_ACTION, AppDownloadManager.ACTION_ONLINE_DOWNLOAD_START);
		                        		 intent_notify.putExtra(AppDownloadManager.TYPE_PACKAGENAME, pkgname);
		                        		 // intent_notify.putExtra(AppDownloadManager.TYPE_PROGRESS, 0);
		                        		 mLauncher.sendBroadcast(intent_notify);
	                        		 	
		                      			 String url=intent.getStringExtra(ExappUtil.DOWNLOAD_URL);
		                      			
		                      			 Log.d("zyfonline","onClick : url = "+url+" , fullpath = "+fullpath);
		                    			 Intent intent_download=new Intent(ExappUtil.ACTION_TPW_FOLDERONLINE_DOWNLOAD_ONE);
		                    			 intent_download.putExtra(ExappUtil.EXTAR_SAVE_FILEPATH,fullpath);
		                    			 intent_download.putExtra(ExappUtil.EXTRA_DOWNLOAD_URL, url);
		                    			 mLauncher.sendBroadcast(intent_download);
		                    			 item.setAppDownloadStatus(AppDownloadStatus.STATUS_WAITING);
                        		 	}
	                        	 }
        					}
                    	}
                    }
                  //topwise zyf add for folderonline end
                    else 
                    {
                    //topwise zyf add end
                    mLauncher.startActivitySafely(v, item.intent, item);
                    if (item.itemType == LauncherSettings.BaseLauncherColumns.ITEM_TYPE_APPLICATION) {
                          ((LauncherApplication)mLauncher.getApplicationContext())
                              .collectUsageData(item.id);
                    }
                }
              //topwise zyf add for exapp
                }
              //topwise zyf add end
            }
        }
    }
    public void showSelectApps(int[] pos) {
        if(mRunningAnimatorSet != null) {
            if(!mRunningIsShow) {
                mRunningAnimatorSet.end();
            } else {
                return;
            }
        }
        if(mAppsSelectView == null) {
            mAppsSelectView = (FolderAppsSelectView)LayoutInflater.from(getContext()).inflate(R.layout.folder_apps_select, null);
            mAppsSelectView.init(this, mInfo, mLauncher);
            mLauncher.getDragLayer().addView(mAppsSelectView);
        }
        mAppsSelectView.initSelectedState(mInfo);
        mAppsSelectView.setScaleX(0);
        mAppsSelectView.setScaleY(0);
        mAppsSelectView.setPivotX(pos[0]);
        mAppsSelectView.setPivotY(pos[1]);
        ObjectAnimator visToInvis = ObjectAnimator.ofFloat(this, "alpha", 1, 0);
        visToInvis.setDuration(mAnimatorDuration);
        ObjectAnimator invisToVisX = ObjectAnimator.ofFloat(mAppsSelectView, "scaleX", 0, 1);
        invisToVisX.setDuration(mAnimatorDuration);
        ObjectAnimator invisToVisY = ObjectAnimator.ofFloat(mAppsSelectView, "scaleY", 0, 1);
        invisToVisY.setDuration(mAnimatorDuration);
        List<Animator> animList = new ArrayList<Animator>();
        animList.add(visToInvis);
        animList.add(invisToVisX);
        animList.add(invisToVisY);
        final AnimatorSet as = new AnimatorSet();
        as.setInterpolator(new LinearInterpolator());
        as.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animator) {
                mAppsSelectView.setVisibility(View.VISIBLE);
                mRunningAnimatorSet = as;
                mRunningIsShow = true;
            }
            @Override
            public void onAnimationEnd(Animator animator) {
                mRunningAnimatorSet = null;
                mRunningIsShow = false;
                Folder.this.setVisibility(View.INVISIBLE);
                mAppsSelectView.setVisibility(View.VISIBLE);
                DisplayMetrics metric = new DisplayMetrics();
                mLauncher.getWindowManager().getDefaultDisplay().getMetrics(metric);
                int width = metric.widthPixels;
                int height = metric.heightPixels;
                mAppsSelectView.setPivotX(width/2);
                mAppsSelectView.setPivotY(height/2);
                mAppsSelectView.setFocusableInTouchMode(true);
                mAppsSelectView.setFocusable(true);
                mAppsSelectView.requestFocus();
            }
        });
        as.playTogether(animList);
        as.start();
    }
    public AnimatorSet getmRunningAnimatorSet() {
        return mRunningAnimatorSet;
    }

    public void setmRunningAnimatorSet(AnimatorSet mRunningAnimatorSet) {
        this.mRunningAnimatorSet = mRunningAnimatorSet;
    }

    public boolean ismRunningIsShow() {
        return mRunningIsShow;
    }

    public void setmRunningIsShow(boolean mRunningIsShow) {
        this.mRunningIsShow = mRunningIsShow;
    }
    public boolean onLongClick(View v) {
        // Return if global dragging is not enabled
        if (!mLauncher.isDraggingEnabled()) return true;
        //downloading item in folder can be drag
        /*if(mLauncher.getModel().isDownloadStatus()) {
            ToastManager.makeToast(ToastManager.NOT_ALLOW_EDIT_IN_DOWNING);
            return true;
        }*/

        if (HomeShellSetting.getFreezeValue(getContext())) {
            boolean toastShow = true;
            if(CheckVoiceCommandPressHelper.PUSH_TO_TALK_SUPPORT) {
                Object object = v.getTag();
                if(object  instanceof ShortcutInfo) {
                    toastShow = !CheckVoiceCommandPressHelper.getInstance().isVoiceApp((ShortcutInfo) object);
                }
            }
            if(toastShow) {
                Toast.makeText(getContext(), R.string.aged_freeze_homeshell_toast, Toast.LENGTH_SHORT).show();
            }
            return true;
        }

        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            ShortcutInfo item = (ShortcutInfo) tag;
            if (!v.isInTouchMode()) {
                return false;
            }
            if(item.isEditFolderShortcut()) {
                return false;
            }
          
            mLauncher.getWorkspace().onDragStartedWithItem(v);
            //mLauncher.getWorkspace().beginDragShared(v, this);
            CellLayout.CellInfo cellInfo = new CellLayout.CellInfo();
            cellInfo.cell = v;
            cellInfo.cellX = item.cellX;
            cellInfo.cellY = item.cellY;
            cellInfo.container = item.container;
            cellInfo.screen = item.screen;
            cellInfo.spanX = item.spanX;
            cellInfo.spanY = item.spanY;
            mLauncher.getWorkspace().startDrag(cellInfo, this);
            mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

            mCurrentDragInfo = item;
            mEmptyCell[0] = item.cellX;
            mEmptyCell[1] = item.cellY;
            mCurrentDragView = v;

            mContent.removeView(mCurrentDragView);
            mInfo.remove(mCurrentDragInfo);
            mDragInProgress = true;
            mItemAddedBackToSelfViaIcon = false;
            if (mInfo.isEditFolderInContents()) {
                int screen = mInfo.getmEditFolderShortcutInfo().screen;
                int editFolderCellX = mInfo.getmEditFolderShortcutInfo().cellX;
                int editFolderCellY = mInfo.getmEditFolderShortcutInfo().cellY;
                mEditFolderTempView = mContentList.get(screen).getChildAt(editFolderCellX,
                        editFolderCellY);
                mContent.removeView(mEditFolderTempView);
                mEditFolderHidden = true;
            }
        }
        return true;
    }

    public boolean isEditingName() {
        return mIsEditingName;
    }

    public void startEditingFolderName() {
        // mFolderName.setHint("");
        mIsEditingName = true;
    }

    public void dismissEditingName() {
        mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        doneEditingFolderName(true);
    }
    
    private void showFolderNameOutline(boolean show){
        if(show){
             mFolderName.setBackgroundResource(R.drawable.bg_folder_name);
        }else{
             mFolderName.setBackground(null);
             mFolderName.clearFocus();
        }
    }
    
    private void showDragOutline(boolean show){
        if(show){
            //when show drag outline ,first hide the name outline
            showFolderNameOutline(false);
            mFolderViewPager.setBackgroundResource(R.drawable.folder_drag_outline);
        }else{
            mFolderViewPager.setBackground(null);
        }
    }

    public void doneEditingFolderName(boolean commit) {
        // mFolderName.setHint(sHintText);
        // Convert to a string here to ensure that no other state associated with the text field
        // gets saved.
        String newTitle = mFolderName.getText().toString();

        if (newTitle == null || newTitle.trim().equals("")) {
            newTitle = mInfo.title.toString();
            mFolderName.clearFocus();
            mFolderName.selectAll();
        }
        if (newTitle != null) {
            newTitle = newTitle.trim();
        }
        mFolderName.setText(newTitle);
        String oldTitle = mInfo.title.toString();
        mInfo.setTitle(newTitle);
        LauncherModel.updateItemInDatabase(mLauncher, mInfo);

        if (commit) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                    String.format(getContext().getString(R.string.folder_renamed), newTitle));
        }
        // In order to clear the focus from the text field, we set the focus on ourself. This
        // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
/*        requestFocus();

        Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);*/

        Map<String, String> param = new HashMap<String, String>();
        param.put("Before", oldTitle);
        param.put("After", newTitle);
        UserTrackerHelper.sendUserReport(UserTrackerMessage.MSG_RENAME_FOLDER, param);

        mIsEditingName = false;
    }

    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
        if (actionId == EditorInfo.IME_ACTION_DONE) {
            int start = mFolderName.getSelectionStart();
            int oldLength = mFolderName.getText().length();
            dismissEditingName();
            int length = mFolderName.getText().length();
            if (oldLength != length) {
                if (start == oldLength) {
                    start = length;
                } else {
                    start = 0;
                }
            }
            if (start < 0) {
                start = 0;
            }
            mFolderName.setSelection(start);
            return true;
        }
        return false;
    }

    public View getEditTextRegion() {
        return mFolderName;
    }

    public Drawable getDragDrawable() {
        return mIconDrawable;
    }

    /**
     * We need to handle touch events to prevent them from falling through to the workspace below.
     */
    @Override
    public boolean onTouchEvent(MotionEvent ev) {
       mLauncher.closeFolder();
       return true;
    }

    public void setDragController(DragController dragController) {
        mDragController = dragController;
    }

    void setFolderIcon(FolderIcon icon) {
        mFolderIcon = icon;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        // When the folder gets focus, we don't want to announce the list of items.
        return true;
    }

    /**
     * @return the FolderInfo object associated with this folder
     */
    FolderInfo getInfo() {
        return mInfo;
    }

    private class GridComparator implements Comparator<ShortcutInfo> {
        int mNumCols;
        public GridComparator(int numCols) {
            mNumCols = numCols;
        }

        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            int lhIndex = lhs.screen * getMaxItemsCountPerPage() + lhs.cellY * mNumCols + lhs.cellX;
            int rhIndex = rhs.screen * getMaxItemsCountPerPage() + rhs.cellY * mNumCols + rhs.cellX;
            return (lhIndex - rhIndex);
        }
    }

    private void placeInReadingOrder(ArrayList<ShortcutInfo> items) {
        int maxX = 0;
        int count = items.size();
        for (int i = 0; i < count; i++) {
            ShortcutInfo item = items.get(i);
            if (item.cellX > maxX) {
                maxX = item.cellX;
            }
        }

        GridComparator gridComparator = new GridComparator(maxX + 1);
        Collections.sort(items, gridComparator);
        final int countX = mContent.getCountX();
        final int maxItemsPerPage = getMaxItemsCountPerPage();
        for (int i = 0; i < count; i++) {
            int screen = i / maxItemsPerPage;
            int x = (i - screen * maxItemsPerPage) % countX;
            int y = (i - screen * maxItemsPerPage) / countX;
            ShortcutInfo item = items.get(i);
            item.screen = screen;
            item.cellX = x;
            item.cellY = y;
        }
    }

    void bind(FolderInfo info) {
        mInfo = info;
        ArrayList<ShortcutInfo> children = info.contents;

        if (children == null) {
            return;
        }

        ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
        setupContentForNumItems(children.size());
        placeInReadingOrder(children);
        int count = 0;
        for (int i = 0; i < children.size(); i++) {
            ShortcutInfo child = (ShortcutInfo) children.get(i);
            if (!createAndAddShortcut(child)) {
                overflow.add(child);
            } else {
                count++;
            }
        }

        // We rearrange the items in case there are any empty gaps
        setupContentForNumItems(count);

        // If our folder has too many items we prune them from the list. This is an issue 
        // when upgrading from the old Folders implementation which could contain an unlimited
        // number of items.
        for (ShortcutInfo item: overflow) {
            mInfo.remove(item);
            LauncherModel.deleteItemFromDatabase(mLauncher, item);
        }

        mItemsInvalidated = true;
        updateTextViewFocus();
        mInfo.addListener(this);

        if (!sDefaultFolderName.contentEquals(mInfo.title)) {
            mFolderName.setText(mInfo.title);
        } else {
            mFolderName.setText(R.string.folder_hint_text);
        }
        updateItemLocationsInDatabase();
    }

    void updateFolderName(CharSequence title) {
        mItemsInvalidated = true;
        updateTextViewFocus();

        mInfo.title = title;

        if (!sDefaultFolderName.contentEquals(title)) {
            mFolderName.setText(title);
        } else {
            mFolderName.setText(R.string.folder_hint_text);
        }

        LauncherModel.updateItemInDatabase(mLauncher, mInfo);
    }

    /**
     * Creates a new UserFolder, inflated from R.layout.user_folder.
     *
     * @param context The application's context.
     *
     * @return A new UserFolder.
     */
    static Folder fromXml(Context context) {
        return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
    }

    /**
     * This method is intended to make the UserFolder to be visually identical in size and position
     * to its associated FolderIcon. This allows for a seamless transition into the expanded state.
     */
    private void positionAndSizeAsIcon() {
        if (!(getParent() instanceof DragLayer)) return;
        setScaleX(0.8f);
        setScaleY(0.8f);
        setAlpha(0f);
        setState(STATE_SMALL);
    }

    public void animateOpen() {
        positionAndSizeAsIcon();
        if (!(getParent() instanceof DragLayer)) return;
        centerAboutIcon();
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
       
        oa.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animation) {
                sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
                        String.format(getContext().getString(R.string.folder_opened),
                        mContent.getCountX(), mContent.getCountY()));
                mState = STATE_ANIMATING;
            }
            @Override
            public void onAnimationEnd(Animator animation) {
                mState = STATE_OPEN;
                setLayerType(LAYER_TYPE_NONE, null);
                
                setFocusOnFirstChild();
                setAlpha(1);
                setScaleX(1);
                setScaleY(1);
            }
        });
        oa.setDuration(mExpandDuration);
        setLayerType(LAYER_TYPE_HARDWARE, null);
        oa.start();
    }

    public void sendCustomAccessibilityEvent(int type, String text) {
        AccessibilityManager accessibilityManager = (AccessibilityManager)
                getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
        if (accessibilityManager.isEnabled()) {
            AccessibilityEvent event = AccessibilityEvent.obtain(type);
            onInitializeAccessibilityEvent(event);
            event.getText().add(text);
            accessibilityManager.sendAccessibilityEvent(event);
        }
    }

    public void setFocusOnFirstChild() {
        View firstChild = mContent.getChildAt(0, 0);
        if (firstChild != null) {
            firstChild.requestFocus();
        }
    }

    public void animateClosed() {
        if (!(getParent() instanceof DragLayer)) return;
        // removed all old animation code to avoid animation conflict
        //PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 0);
        //PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 0.9f);
        //PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 0.9f);
        //final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
        //oa.addListener(new AnimatorListenerAdapter() {
        //    @Override
        //    public void onAnimationEnd(Animator animation) {
                onCloseComplete();
                setLayerType(LAYER_TYPE_NONE, null);
                mState = STATE_SMALL;
                final Resources r = mLauncher.getResources();
                List<View> items = getItemsInReadingOrder();
                for (View item : items) {
                    item.setVisibility(View.VISIBLE);
                    item.setAlpha(1);
                    item.setScaleX(1);
                    item.setScaleY(1);
                }
                final int height = LauncherApplication.getScreenHeight();
                final int width = LauncherApplication.getScreenWidth();
                mLauncher.getIndicatorView().setY((width > height ? width : height) - r.getDimensionPixelSize(R.dimen.page_indicator_workspace_marginbottom)  - r.getDimensionPixelSize(R.dimen.page_indicator_height));
                    mLauncher.getWorkspace().setVisibility(View.VISIBLE);
                    mLauncher.getWindow().getDecorView().setBackground(null);
    	        CellLayout hotseat = mLauncher.getHotseat().getLayout();
    	        ShortcutAndWidgetContainer hotseatContainer = hotseat.getShortcutAndWidgetContainer();
    	        int hotseatChildCount = hotseatContainer.getChildCount();
    	        for(int i=0;i<hotseatChildCount;i++) {
    	            View child = hotseatContainer.getChildAt(i);
                    if (child.getAlpha() < 1) {
                        child.setAlpha(1);
                        continue;
                    }
                    child.setY(0); // reset y to zero, it's original position
    	        }
                mLauncher.getWorkspace().setAllItemsOfCurrentPageVisibility(View.VISIBLE);
        // removed all old animation code to avoid animation conflict
        //    }
        //    @Override
        //    public void onAnimationStart(Animator animation) {
        //        sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
        //                getContext().getString(R.string.folder_closed));
        //        mState = STATE_ANIMATING;
        //    }
        //});
        //oa.setDuration(mExpandDuration);
        //setLayerType(LAYER_TYPE_HARDWARE, null);
        //oa.start();
    }

    public void onThemeChanged() {
        // recreate all the children and updateLayout if the theme change)
        for (CellLayout mContent : mContentList) {
            mContent.removeAllViewsInLayout();
        }
        mItemsInReadingOrder.clear();
        updateFolderLayout(isSupportCardIcon());
        bind(mInfo);
    }

    public boolean acceptDrop(DragObject d) {
        final ItemInfo item = (ItemInfo) d.dragInfo;
        final int itemType = item.itemType;
        
        boolean folderAcceptDrop = ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT_DOWNLOADING ||
                itemType == LauncherSettings.Favorites.ITEM_TYPE_VPINSTALL) &&
                !isFull());
        Log.d(TAG, "sxsexe--------->acceptDrop folderAcceptDrop " + folderAcceptDrop);
        return folderAcceptDrop;
    }

    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
        int[] emptyCell = new int[2];
        int screen = 0;
        for (screen = 0; screen < mContentList.size(); screen++) {
            if (mContentList.get(screen).findCellForSpan(emptyCell, item.spanX, item.spanY)) {
                item.screen = screen;
                item.cellX = emptyCell[0];
                item.cellY = emptyCell[1];
                return true;
            }
        }
            return false;
    }

    protected boolean createAndAddShortcut(ShortcutInfo item) {   
        final BubbleTextView textView =
                (BubbleTextView) mInflater.inflate(R.layout.application, this, false);
            textView.applyFromShortcutInfo(item);
            //in the function "applyFromShortcutInfo", the text has been alread set by BubbleTextView.setTitle
            //textView.setText(item.title); 
            textView.setTag(item);
            textView.updateView(item);

            textView.setOnClickListener(this);
            textView.setOnLongClickListener(this);

            // We need to check here to verify that the given item's location isn't already occupied
            // by another item.
        if (item.screen >= mContentList.size()
                || mContentList.get(item.screen).getChildAt(item.cellX, item.cellY) != null
                || item.cellX < 0 || item.cellY < 0
                || item.cellX >= mContentList.get(item.screen).getCountX()
                || item.cellY >= mContentList.get(item.screen).getCountY()) {
                // This shouldn't happen, log it. 
            Log.e(TAG,
                    "Folder order not properly persisted during bind,the item is" + item.toString());
                if (!findAndSetEmptyCells(item)) {
                    return false;
                }
            }

        CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX, item.cellY,
                item.spanX, item.spanY);
        boolean insert = false;
        textView.setOnKeyListener(new FolderKeyEventListener());
        textView.setHapticFeedbackEnabled(false);
        mContentList.get(item.screen).addViewToCellLayout(textView, insert ? 0 : -1, (int) item.id,
                lp, true);
            return true;
    }

    public void onDragEnter(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        showDragOutline(true);
        mPreviousTargetCell[0] = -1;
        mPreviousTargetCell[1] = -1;
        mOnExitAlarm.cancelAlarm();
        mDraggingToLeftEdge = false;
        mDraggingToRightEdge = false;
    }

    OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            try {
                cancelMoveAnimation();
                realTimeReorder(mEmptyCell, mTargetCell);
            } catch (Exception e) {
                Log.e(TAG, "reorder error", e);
            }
        }
    };

    boolean readingOrderGreaterThan(int[] v1, int[] v2) {
        if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
            return true;
        } else {
            return false;
        }
    }

    private void realTimeReorder(int[] empty, int[] target) {
        boolean wrap;
        int startX;
        int endX;
        int startY;
        int delay = 0;
        float delayAmount = 30;
        if (readingOrderGreaterThan(target, empty)) {
            wrap = empty[0] >= mContent.getCountX() - 1;
            startY = wrap ? empty[1] + 1 : empty[1];
            for (int y = startY; y <= target[1]; y++) {
                startX = y == empty[1] ? empty[0] + 1 : 0;
                endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
                for (int x = startX; x <= endX; x++) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        } else {
            wrap = empty[0] == 0;
            startY = wrap ? empty[1] - 1 : empty[1];
            for (int y = startY; y >= target[1]; y--) {
                startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX() - 1;
                endX = y > target[1] ? 0 : target[0];
                for (int x = startX; x >= endX; x--) {
                    View v = mContent.getChildAt(x,y);
                    if (mContent.animateChildToPosition(v, empty[0], empty[1],
                            REORDER_ANIMATION_DURATION, delay, true, true)) {
                        empty[0] = x;
                        empty[1] = y;
                        delay += delayAmount;
                        delayAmount *= 0.9;
                    }
                }
            }
        }
    }

    public boolean isLayoutRtl() {
        return (getLayoutDirection() == LAYOUT_DIRECTION_RTL);
    }

    public void onDragOver(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        if (mScrolling)
            return;
        float[] r = getDragViewVisualCenter(d.x, d.y - getFolderNamePadding(), d.xOffset, d.yOffset, d.dragView, null);
        mTargetCell = mContent.findNearestArea((int) r[0], (int) r[1], 1, 1, mTargetCell);

        if (isLayoutRtl()) {
            mTargetCell[0] = mContent.getCountX() - mTargetCell[0] - 1;
        }

        if (mTargetCell[0] != mPreviousTargetCell[0] || mTargetCell[1] != mPreviousTargetCell[1]) {
            mReorderAlarm.cancelAlarm();
            mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
            mReorderAlarm.setAlarm(150);
            mPreviousTargetCell[0] = mTargetCell[0];
            mPreviousTargetCell[1] = mTargetCell[1];
        }
        mDraggingToLeftEdge = false;
        mDraggingToRightEdge = false;
    }

    // This is used to compute the visual center of the dragView. The idea is that
    // the visual center represents the user's interpretation of where the item is, and hence
    // is the appropriate point to use when determining drop location.
    private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
            DragView dragView, float[] recycle) {
        float res[];
        if (recycle == null) {
            res = new float[2];
        } else {
            res = recycle;
        }

        // These represent the visual top and left of drag view if a dragRect was provided.
        // If a dragRect was not provided, then they correspond to the actual view left and
        // top, as the dragRect is in that case taken to be the entire dragView.
        // R.dimen.dragViewOffsetY.
        int left = x - xOffset;
        int top = y - yOffset;

        // In order to find the visual center, we shift by half the dragRect
        res[0] = left + dragView.getDragRegion().width() / 2;
        res[1] = top + dragView.getDragRegion().height() / 2;

        return res;
    }

    OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
        public void onAlarm(Alarm alarm) {
            completeDragExit();
        }
    };

    public void completeDragExit() {
        setupContentForNumItems(getItemCount());

//        mLauncher.closeFolder();
        mLauncher.closeFolderWithoutExpandAnimation();
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        mRearrangeOnClose = true;
    }

    public void onDragExit(DragObject d) {
        if (mState == Folder.STATE_ANIMATING) {
            return;
        }
        // We only close the folder if this is a true drag exit, ie. not because a drop
        // has occurred above the folder.
        if (!d.dragComplete) {
            mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
            mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
        }
        cancelMoveAnimation();
        mReorderAlarm.cancelAlarm();
        mDragExit = true;
    }

    public void onDropCompleted(View target, DragObject d, boolean isFlingToDelete,
            boolean success) {
        mDropAccepted = success;
        Log.d(TAG, "sxsexe---------> onDropCompleted dragInfo " + d.dragInfo 
                + " success " + success
                + " mDeleteFolderOnDropCompleted " + mDeleteFolderOnDropCompleted
                + " mItemAddedBackToSelfViaIcon " + mItemAddedBackToSelfViaIcon
                + " item count " + getItemCount()
                + " mHasDirtyData " + mHasDirtyData);
        showDragOutline(false);
        mShortcutInfoCache = (ShortcutInfo)d.dragInfo;
        mLauncher.setCurrentFolder(this);
        if (success) {
            if(target instanceof DeleteDropTarget && mShortcutInfoCache.itemType == Favorites.ITEM_TYPE_APPLICATION) {
                //go to uninstall or remove, 
                Log.d(TAG, "sxsexe---------> onDropCompleted do not need to replaceFolderWithFinalItem");
                mHasDirtyData = true;
                if ((mShortcutInfoCache.intent != null) &&
                     (mShortcutInfoCache.intent.getComponent() !=null) &&
                     (mShortcutInfoCache.intent.getComponent().getPackageName() != null)) {
                    boolean storgeMount = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);

                    String packageName = mShortcutInfoCache.intent.getComponent().getPackageName();
                    final PackageManager packageManager = ((Context)mLauncher).getPackageManager();

                    final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
                    mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
                    mainIntent.setPackage(packageName);
                    final List<ResolveInfo> apps = packageManager.queryIntentActivities(mainIntent, 0);
                    if((apps == null || apps.size() == 0)&&(storgeMount == true)) {
                        Log.d(TAG, "sxsexe------->no app info, so it need to be cleaned");
                        mHasDirtyData = false;
                    }
               }
            }
            mDeleteFolderOnDropCompleted =  mInfo.count() <= 1;
            if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon && !(target instanceof DeleteDropTarget)) {
                if(!mHasDirtyData) {
                    //drag to workspace or hotseat
                    replaceFolderWithFinalItem();
                    this.setNeedReplaceFolderWithFinalItemFlase();
                }
            }
            if(!mDeleteFolderOnDropCompleted && (target != this) && !(target instanceof DeleteDropTarget)) {
                ShortcutInfo item;
                if (d.dragInfo instanceof ApplicationInfo) {
                    item = ((ApplicationInfo) d.dragInfo).makeShortcut();
                } else {
                    item = (ShortcutInfo) d.dragInfo;
                }
                updateFolderNameWithRemainedApp(item);
            }
        } else {
            Log.d(TAG, "sxsexe---------> onDropCompleted drag failed need to get the item back " );
            // The drag failed, we need to return the item to the folder
            mFolderIcon.onDrop(d);

            // We're going to trigger a "closeFolder" which may occur before this item has
            // been added back to the folder -- this could cause the folder to be deleted
            if (mOnExitAlarm.alarmPending()) {
                mSuppressFolderDeletion = true;
            }
        }

        if (target != this) {
            if (mOnExitAlarm.alarmPending()) {
                mOnExitAlarm.cancelAlarm();
                completeDragExit();
            }
        }
        mDeleteFolderOnDropCompleted = false;
        mDragInProgress = false;
        mItemAddedBackToSelfViaIcon = false;
        mCurrentDragInfo = null;
        mCurrentDragView = null;
        mSuppressOnAdd = false;
        if (target == this && mInfo.isEditFolderInContents()
                && mEditFolderTempView != null) {
            int childId = mEditFolderTempView.getId();
            CellLayout.LayoutParams params = (CellLayout.LayoutParams) mEditFolderTempView
                    .getLayoutParams();
            mContentList.get(mInfo.getmEditFolderShortcutInfo().screen).addViewToCellLayout(
                    mEditFolderTempView, -1, childId,
                    params, true);
            mEditFolderHidden = false;
        }
        // Reordering may have occured, and we need to save the new item locations. We do this once
        // at the end to prevent unnecessary database operations.
        updateItemLocationsInDatabase();
        mLauncher.getWorkspace().cleanDragInfoFromFolder();
        mLauncher.getWorkspace().checkAndRemoveEmptyCell();
    }

    @Override
    public boolean supportsFlingToDelete() {
        return true;
    }

    public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
        // Do nothing
    }

    @Override
    public void onFlingToDeleteCompleted() {
        // Do nothing
    }

    private void updateItemLocationsInDatabase() {
        ArrayList<View> list = getItemsInReadingOrder();
        for (int i = 0; i < list.size(); i++) {
            View v = list.get(i);
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.itemFlags != Favorites.ITEM_FLAGS_EDIT_FOLDER) {
                LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, info.screen,
                        info.cellX, info.cellY);
            }
        }
    }

    public void notifyDrop() {
        if (mDragInProgress) {
            mItemAddedBackToSelfViaIcon = true;
        }
    }

    public boolean isDropEnabled() {
        return true;
    }

    public DropTarget getDropTargetDelegate(DragObject d) {
        return null;
    }

    private void setupContentDimensions(int count) {
        if (count <= 0) {
            return;
        }
        ArrayList<View> list = getItemsInReadingOrder(mState == STATE_OPEN);
        // the view amount in folder and the shortcutinfo amount in folder may
        // diff when onDrop
        if (list.size() != count) {
            count = Math.max(list.size(), count);
        }
        /*
         * int countX = mContent.getCountX();
         * int countY = mContent.getCountY();
         * boolean done = false;
         * while (!done) { int oldCountX = countX; int oldCountY = countY; if
         * (countX * countY < count) { // Current grid is too small, expand it
         * if ((countX <= countY || countY == mMaxCountY) && countX <
         * mMaxCountX) { countX++; } else if (countY < mMaxCountY) { countY++; }
         * if (countY == 0) countY++; } else if ((countY - 1) * countX >= count
         * && countY >= countX) { countY = Math.max(0, countY - 1); } else if
         * ((countX - 1) * countY >= count) { countX = Math.max(0, countX - 1);
         * } done = countX == oldCountX && countY == oldCountY; }
         */

        int countX = mMaxCountX;
        int countY = 0;
        if (mEditFolderHidden) {
            count++;
        }
        for (CellLayout mContent : mContentList) {
            mContent.removeAllViews();
        }
        int pageCount = count / getMaxItemsCountPerPage()
                + ((count % getMaxItemsCountPerPage() == 0) ? 0 : 1);
        int maxPage = MAX_ITEMS_COUNT / getMaxItemsCountPerPage();
        if (pageCount > maxPage) {
            pageCount = maxPage;
        }
        adjustContentListSize(pageCount);
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        for (int page = pageCount - 1; page >= 0; page--) {
            mContentList.get(page).setGridSize(mMaxCountX, mMaxCountY);
        }
        arrangeChildren(list);
    }

    public boolean isFull() {
        return getItemCount() >= MAX_ITEMS_COUNT;
    }

    @Deprecated
    private void centerAboutIcon() {
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

        int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
        int height = getPaddingTop() + getPaddingBottom() + mContent.getDesiredHeight()
                + mFolderNameHeight + mFolderNameContentGap;
        DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);

        float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

        int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
        int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
        int centeredLeft = centerX - width / 2;
        int centeredTop = centerY - height / 2;

        int currentPage = mLauncher.getWorkspace().getCurrentPage();
        // In case the workspace is scrolling, we need to use the final scroll to compute
        // the folders bounds.
        // We first fetch the currently visible CellLayoutChildren
        CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
        if (currentLayout != null) {
            mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
            ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
            Rect bounds = new Rect();
            parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
            // We reset the workspaces scroll
            mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);
        }
//        // We need to bound the folder to the currently visible CellLayoutChildren
//        int left = Math.min(Math.max(bounds.left, centeredLeft),
//                bounds.left + bounds.width() - width);
//        int top = Math.min(Math.max(bounds.top, centeredTop),
//                bounds.top + bounds.height() - height);
//        // If the folder doesn't fit within the bounds, center it about the desired bounds
//        if (width >= bounds.width()) {
//            left = bounds.left + (bounds.width() - width) / 2;
//        }
//        if (height >= bounds.height()) {
//            top = bounds.top + (bounds.height() - height) / 2;
//        }
//        
//        int parentHeight = parent.getWidth();
//        if (top > parentHeight / 2) {
//            top = parentHeight / 2;
//        }
//
//        int folderPivotX = width / 2 + (centeredLeft - left);
//        int folderPivotY = height / 2 + (centeredTop - top);
//        setPivotX(folderPivotX);
//        setPivotY(folderPivotY);
//        mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() *
//                (1.0f * folderPivotX / width));
//        mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() *
//                (1.0f * folderPivotY / height));

        lp.width = width;
        lp.height = height;
        
        int screenwidth = LauncherApplication.getScreenWidth();
        int screenheight = LauncherApplication.getScreenHeight();
//        lp.x = (screenwidth-width)/2;
//        lp.y = (screenheight-height)/2;
        lp.x = ((screenwidth > screenheight ? screenheight : screenwidth)-width)/2;
        lp.y = ((screenwidth > screenheight ? screenwidth : screenheight)-height)/2;
//        lp.x = getPaddingLeft();
//        lp.y = getPaddingTop();
//        lp.width = screenwidth - getPaddingLeft() - getPaddingRight();
//        lp.height = screenheight - getPaddingTop() - getPaddingBottom();
    }

    float getPivotXForIconAnimation() {
        return mFolderIconPivotX;
    }
    float getPivotYForIconAnimation() {
        return mFolderIconPivotY;
    }

    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        //centerAboutIcon();
    }

    private int mPageIndicatorHeight = getResources().getDimensionPixelSize(
            R.dimen.page_indicator_height);
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        View parent = mLauncher.getDragLayer();
        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        int contentWidth = mContentWidth;
        int contentHeight = mContentHeight;
        int width = getPaddingLeft() + getPaddingRight() + contentWidth;
        int height = getPaddingTop() + getPaddingBottom() + contentHeight
                + mFolderNameHeight + mFolderNameContentGap + mPageIndicatorHeight;
        lp.width = width;
        lp.height = height;
        lp.x = (parent.getWidth() - width) / 2;
        if (AgedModeUtil.isAgedMode()) {
            lp.y = (parent.getHeight() - height) / 2;
        } else {
            lp.y = (parent.getHeight() - height) / 2 - mFolderNameContentGap;
        }

        int contentWidthSpec = MeasureSpec.makeMeasureSpec(contentWidth,
                MeasureSpec.EXACTLY);
        int contentHeightSpec = MeasureSpec.makeMeasureSpec(contentHeight,
                MeasureSpec.EXACTLY);
        mFolderViewPager.measure(contentWidthSpec, contentHeightSpec);

        contentWidthSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.AT_MOST);
        contentHeightSpec = MeasureSpec.makeMeasureSpec(mPageIndicatorHeight, MeasureSpec.AT_MOST);
        mPageIndicator.measure(contentWidthSpec, contentHeightSpec);
        int titleWidthSpec = MeasureSpec.makeMeasureSpec(width,
                MeasureSpec.AT_MOST);
        int titleHeightSpec = MeasureSpec.makeMeasureSpec(mFolderNameHeight,
                MeasureSpec.EXACTLY);
        mFolderName.measure(titleWidthSpec, titleHeightSpec);
        setMeasuredDimension(width, height);
    }

    private void arrangeChildren(ArrayList<View> list) {
        int[] vacant = new int[2];
        if (list == null) {
            list = getItemsInReadingOrder(mState == STATE_OPEN);
        }
        for (CellLayout mContent : mContentList) {
            mContent.removeAllViews();
        }
        int pageCount = 0;
        CellLayout mContent = mContentList.get(pageCount);
        for (int i = 0; i < list.size(); i++) {
            if (i > 0 && i % getMaxItemsCountPerPage() == 0) {
                pageCount++;
                mContent = mContentList.get(pageCount);
            }
            View v = list.get(i);
            mContent.getVacantCell(vacant, 1, 1);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
            lp.cellX = vacant[0];
            lp.cellY = vacant[1];
            ItemInfo info = (ItemInfo) v.getTag();
            if (info.screen != pageCount || info.cellX != vacant[0] || info.cellY != vacant[1]) {
                info.screen = pageCount;
                info.cellX = vacant[0];
                info.cellY = vacant[1];
                LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, pageCount,
                        info.cellX, info.cellY);
            }
            boolean insert = false;
            mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
        }
        mItemsInvalidated = true;
    }

    public int getItemCount() {
        int count = 0;
        for (CellLayout mContent : mContentList) {
            count += mContent.getShortcutAndWidgetContainer().getChildCount();
        }
        return count;
    }

    public View getItemAt(int index) {
        int calcIndex  = index / getMaxItemsCountPerPage();
        if (calcIndex >= mContentList.size()) {
            //error status, retrun the last item in ContentList
            if (mContentList.size() <= 0) {
                return null;
            }
            ShortcutAndWidgetContainer container = mContentList.get(mContentList.size() - 1).getShortcutAndWidgetContainer();
            if (container.getChildCount() <= 0) {
                return null;
            }
            int lastChildIndex = container.getChildCount() - 1;
            return container.getChildAt(lastChildIndex);
        } else {
            return mContentList.get(calcIndex).getShortcutsAndWidgets()
                    .getChildAt(index % getMaxItemsCountPerPage());
        }
    }

    public void onCloseComplete() {
        DragLayer parent = (DragLayer) getParent();
        if (parent != null) {
            parent.removeView(this);
        }
        mDragController.removeDropTarget((DropTarget) this);
        mLauncher.getDragLayer().clearAnimatedView();
        clearFocus();
        mFolderIcon.requestFocus();

        if (mRearrangeOnClose  && mLauncher.checkFolderIdValid(mInfo.id)) {
            setupContentForNumItems(getItemCount());
            mRearrangeOnClose = false;
        }
        
        if (getItemCount() <= 1) {
            if (!mDragInProgress && !mSuppressFolderDeletion) {
                //replaceFolderWithFinalItem();
            } else if (mDragInProgress) {
                mDeleteFolderOnDropCompleted = true;
            }
        }
        mSuppressFolderDeletion = false;
    }

    private boolean mNeedReplaceFolderWithFinalItem;
    public boolean getNeedReplaceFolderWithFinalItem() {
    	return mNeedReplaceFolderWithFinalItem;
    }
    public void setNeedReplaceFolderWithFinalItemFlase() {
    	this.mNeedReplaceFolderWithFinalItem = false;
    }

    public void replaceFolderWithFinalItem() {
        replaceFolderWithFinalItem(true);
    }

    public void replaceFolderWithFinalItem(boolean animated) {
        if (mLauncher.getWorkspace().isPlayingAnimation()) {
        	mNeedReplaceFolderWithFinalItem = true;
    	    return;
        }
        // Add the last remaining child to the workspace in place of the folder
        Runnable onCompleteRunnable = new Runnable() {
            @Override
            public void run() {
                if (mLauncher.getWorkspace().isPlayingAnimation()) {
                	mNeedReplaceFolderWithFinalItem = true;
            	    return;
                }
                CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);

               View child = null;
                // Move the item from the folder to the workspace, in the position of the folder
                // mInfo.contents can be already cleared by LauncherModel.checkFolderAndUpdate()
                if (getItemCount() == 1 && !mInfo.contents.isEmpty()) {
                    ShortcutInfo finalItem = mInfo.contents.get(0);
                    child = mLauncher.createShortcut(R.layout.application, cellLayout,
                            finalItem);
                    LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container,
                            mInfo.screen, mInfo.cellX, mInfo.cellY);
                }
                if (getItemCount() <= 1) {
                    // Remove the folder
                    LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                    cellLayout.removeView(mFolderIcon);
                    if (mFolderIcon instanceof DropTarget) {
                        mDragController.removeDropTarget((DropTarget) mFolderIcon);
                    }
                    mLauncher.removeFolder(mInfo);
                }
                // We add the child after removing the folder to prevent both from existing at
                // the same time in the CellLayout.
                if (child != null) {
                    if(mInfo.container == Favorites.CONTAINER_HOTSEAT) {
                        int index = mInfo.screen;
                        mLauncher.getHotseat().onDrop(true,-1,  null, child, true);
                        mLauncher.getWorkspace().addInHotseat(child, mInfo.container, index,
                                index, 0, mInfo.spanX, mInfo.spanY, index);
                    } else {
                        mLauncher.getWorkspace().addInScreen(child, mInfo.container, mInfo.screen,
                                mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
                    }
                }

                LauncherAnimUtils.clearDeadAnimation();
            }
        };
        View finalChild = getItemAt(0);
        if (finalChild != null) {
            if (animated) {
                mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
            } else {
                onCompleteRunnable.run();
            }
        }
        else if (getItemCount() == 0) {
            //in some abnormal case, only one item in folder
            //and the item is moved out of folder, in this case
            //the empty folder need to be deleted
            Log.d(TAG, "only one item in folder and the item is moved out of folder");
            CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screen);
            cellLayout.removeView(mFolderIcon);
            if (mFolderIcon instanceof DropTarget) {
                mDragController.removeDropTarget((DropTarget) mFolderIcon);
            }
            mLauncher.removeFolder(mInfo);
            LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
        }
        mDestroyed = true;
        mHasDirtyData = false;
    }

    boolean isDestroyed() {
        return mDestroyed;
    }

    // This method keeps track of the last item in the folder for the purposes
    // of keyboard focus
    private void updateTextViewFocus() {
        View lastChild = getItemAt(getItemCount() - 1);
        if (lastChild != null) {
            mFolderName.setNextFocusDownId(lastChild.getId());
            mFolderName.setNextFocusRightId(lastChild.getId());
            mFolderName.setNextFocusLeftId(lastChild.getId());
            mFolderName.setNextFocusUpId(lastChild.getId());
        }
    }

    void cancelMoveAnimation() {
        if (moveAnim != null && moveAnim.isStarted()) {
            moveAnim.cancel();
        }
    }

    public void onDrop(DragObject d) {
        mDragExit = false;
        cancelMoveAnimation();
        mReorderAlarm.cancelAlarm();
        //mLauncher.exitFullScreen();
        ShortcutInfo item;
        if (d.dragInfo instanceof ApplicationInfo) {
            // Came from all apps -- make a copy
            item = ((ApplicationInfo) d.dragInfo).makeShortcut();
            item.spanX = 1;
            item.spanY = 1;
        } else {
            item = (ShortcutInfo) d.dragInfo;
        }
        // Dragged from self onto self, currently this is the only path possible, however
        // we keep this as a distinct code path.
        if (item == mCurrentDragInfo) {
            ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView.getLayoutParams();
            si.cellX = lp.cellX = mEmptyCell[0];
            si.cellX = lp.cellY = mEmptyCell[1];
            String title = si.title.toString();
            if(mCurrentDragView.getParent() != null) {
                ((ViewGroup)mCurrentDragView.getParent()).removeView(mCurrentDragView);
                Log.e("Folder", "The icon whose name is :" + title
                        + " has already have the parent when onDrop,remove it to avoid crash");
            }
            mContent.addViewToCellLayout(mCurrentDragView, -1, (int)item.id, lp, true);
            if (d.dragView.hasDrawn()) {
                mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, mCurrentDragView);
            } else {
                d.deferDragViewCleanupPostAnimation = false;
                mCurrentDragView.setVisibility(VISIBLE);
            }
            mItemsInvalidated = true;
            setupContentDimensions(getItemCount());
            mSuppressOnAdd = true;
        } else {
            d.deferDragViewCleanupPostAnimation = false;
        }
        mInfo.add(item);
    }

    public void hideSoftInputMethod(Activity activity) {
        View v;
        if (activity == null || activity.getWindow() == null) {
            v = mFolderName;
        } else {
            v = activity.getWindow().peekDecorView();
        }
        try {
            if (v != null && v.getWindowToken() != null) {
                InputMethodManager imm = (InputMethodManager) getContext()
                        .getSystemService(Context.INPUT_METHOD_SERVICE);
                boolean result = imm
                        .hideSoftInputFromWindow(v.getWindowToken(), 0);
                Log.d(TAG, "hideSoftInputMethod, ret:" + result);
            }
        } catch (RuntimeException e) {
            // add try catch block due to InputMethod throws
            // RuntimeException;
            Log.e(TAG, e.toString(), e);
        }
    }

    public void onAdd(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If the item was dropped onto this open folder, we have done the work associated
        // with adding the item to the folder, as indicated by mSuppressOnAdd being set
        mHasDirtyData = false;
        mDestroyed = false;
        
        if (mSuppressOnAdd) return;

        if (item.container >= 0 && item.cellX >= 0 && item.cellY >= 0) {
            insertItem(item);
            return;
        }
        if (!findAndSetEmptyCells(item)) {
            // The current layout is full, can we expand it?
            setupContentForNumItems(getItemCount() + 1);
            findAndSetEmptyCells(item);
        }
        
        final long originalContainer = item.container;
        createAndAddShortcut(item);
        LauncherModel.addOrMoveItemInDatabase(
                mLauncher, item, mInfo.id, item.screen, item.cellX, item.cellY);
        
        if(item.isEditFolderShortcut()) {
        	mNeedReplaceFolderWithFinalItem = true;
        }

        if (originalContainer == LauncherSettings.Favorites.CONTAINER_HIDESEAT) {
            Hideseat hideseat = mLauncher.getHideseat();
            if (hideseat != null && !hideseat.isDraggingIconToFolder()) {
                // try to find corresponding view for the item
                View iconView = getViewForInfo(item);
                hideseat.onDragIconFromHideseatToFolder(iconView, item, this);
            }
        }
    }

    private void insertItem(ShortcutInfo item) {
        // TODO Auto-generated method stub
        setupContentForNumItems(getItemCount() + 1);
        int xCount = mContent.getCountX();
        int yCount = mContent.getCountY();
        int currentPos = item.screen * xCount * yCount + item.cellY * xCount + item.cellX;
        int maxItemsPerPage = getMaxItemsCountPerPage();
        Collections.sort(mInfo.contents, infoDownComp);
        mInfo.contents.remove(item);
        mInfo.contents.add(item);
        for (ShortcutInfo si : mInfo.contents) {
            int pos = si.screen * xCount * yCount + si.cellY * xCount + si.cellX;
            if (si == item) {
                createAndAddShortcut(si);
                LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, si.screen, si.cellX,
                        si.cellY);
                continue;
            }
            if (pos >= currentPos || (pos == currentPos && !item.equals(si))) {
                View view = mContentList.get(si.screen).getChildAt(si.cellX, si.cellY);
                mContentList.get(si.screen).removeView(view);
                si.screen = (pos + 1) / maxItemsPerPage;
                si.cellX = ((pos + 1) % maxItemsPerPage) % xCount;
                si.cellY = ((pos + 1) % maxItemsPerPage) / xCount;
                if (view == null) {
                    Log.e(TAG, "the view of " + si.title + "should not be null,but now is null");
                    createAndAddShortcut(si);
                } else if (view.getTag() == null || view.getTag() != si) {
                    String title = view.getTag() == null ? "DefaultName"
                            : ((ShortcutInfo) view.getTag()).title.toString();
                    Log.e(TAG, "The shortcutInfo:" + item.title
                            + " is different with the shortcut associated with view:" + title);
                } else {
                    CellLayout.LayoutParams lp = new CellLayout.LayoutParams(si.cellX, si.cellY,
                            si.spanX, si.spanY);
                    boolean insert = false;
                    mContentList.get(si.screen).addViewToCellLayout(view, insert ? 0 : -1,
                            (int) si.id, lp, true);
                }
                LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, si.screen, si.cellX,
                        si.cellY);
            }
        }
    }

    public void onRemove(ShortcutInfo item) {
        mItemsInvalidated = true;
        // If this item is being dragged from this open folder, we have already handled
        // the work associated with removing the item, so we don't have to do anything here.
        if (item == mCurrentDragInfo) return;
        View v = getViewForInfo(item);
        Log.d(TAG, "sxsexe------->onRemove  mContent.childCount " + mContent.getChildCount() + " getItemCount " + getItemCount());
        mHasDirtyData = false;
        mDestroyed = false;
        if ((item.container >= 0) && (mContentList.size() > item.screen)) {
            mContentList.get(item.screen).removeView(v);
        } else {
            Log.d(TAG, "the item is changed. id is " + item.id + " screen is:" + item.screen + " container is:" + item.container);
            for (CellLayout cell: mContentList) {
                cell.removeView(v);
            }
        }
        if (mState == STATE_ANIMATING) {
            mRearrangeOnClose = true;
        } else {
            setupContentForNumItems(getItemCount());
        }
        if (getItemCount() <= 1 && !mLauncher.getDragController().isDragging()
                && !mLauncher.isDragToDelete()
                && mNeedReplaceFolderWithFinalItem) {
            replaceFolderWithFinalItem();
            this.setNeedReplaceFolderWithFinalItemFlase();
        }
    }

    private View getViewForInfo(ShortcutInfo item) {
        Log.d(TAG, "sxsexe-------_> getViewForInfo item " + item + " getCountX() " + mContent.getCountX());
        for (int screen = 0; screen < mContentList.size(); screen++) {
            CellLayout mContent = mContentList.get(screen);
            for (int j = 0; j < mContent.getCountY(); j++) {
                for (int i = 0; i < mContent.getCountX(); i++) {
                    View v = mContent.getChildAt(i, j);
                    Log.d(TAG, "sxsexe--->getViewForInfo i " + i + " j " + j + " v " + v);
                    if (v == null) {
                        continue;
                    }
                    if (v.getTag() == item) {
                        return v;
                    }
                }
            }
        }
        return null;
    }

    public void onItemsChanged() {
        updateTextViewFocus();
    }

    public void invalidateFolder(View v, ShortcutInfo info) {
        // child view attached, do nothing
    }

    public void onTitleChanged(CharSequence title) {
    }

    public ArrayList<View> getItemsInReadingOrder() {
        return getItemsInReadingOrder(true);
    }

    public ArrayList<View> getItemsInReadingOrder(boolean includeCurrentDragItem) {
        if (mItemsInvalidated) {
            mItemsInReadingOrder.clear();
            int screenCount = mContentList.size();
            for (int m = 0; m < screenCount; m++) {
                CellLayout mContent = mContentList.get(m);
                for (int j = 0; j < mContent.getCountY(); j++) {
                    for (int i = 0; i < mContent.getCountX(); i++) {
                        View v = mContent.getChildAt(i, j);
                        if (v != null) {
                            ShortcutInfo info = (ShortcutInfo) v.getTag();
                            if (info != mCurrentDragInfo || includeCurrentDragItem
                                    || !mDropAccepted) {
                                mItemsInReadingOrder.add(v);
                            }
                        }
                    }
                }
            }
            mItemsInvalidated = false;
        }
        return mItemsInReadingOrder;
    }

    public void getLocationInDragLayer(int[] loc) {
        mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
    }

    public void onFocusChange(View v, boolean hasFocus) {
        if (v == mFolderName && hasFocus) {
            startEditingFolderName();
            showFolderNameOutline(true);
        }else{
            showFolderNameOutline(false);
        }
    }
    
    public FolderIcon getmFolderIcon() {
        return mFolderIcon;
    }
    
    public int getState() {
    	return mState;
    }
    
    public void setState(int mState) {
    	this.mState = mState;
    }

    /**
     * Note that this method returns the <strong>current</strong> page
     * of this folder.
     * <p/>
     * To retrieve all the child views, use {@link #getItemCount()}
     * and {@link #getItemAt(int)} instead.
     */
	public CellLayout getContent() {
		return mContent;
	}

    private void setContent(CellLayout mContent) {
		this.mContent = mContent;
	}
	public void closeSelectApps() {
	    if(mRunningAnimatorSet != null) {
            mRunningAnimatorSet.end();
        }
        this.setVisibility(View.VISIBLE);
        if (mAppsSelectView != null) {
            mLauncher.getDragLayer().removeView(mAppsSelectView);
            mAppsSelectView.removeAllViews();
            mAppsSelectView = null;
        }
    }
    public void backFromSelectApps() {
        if(mRunningAnimatorSet != null) {
            if(mRunningIsShow) {
                mRunningAnimatorSet.end();
            } else {
                return;
            }
        }
        ObjectAnimator invisToVis = ObjectAnimator.ofFloat(this, "alpha", 0, 1);
        invisToVis.setDuration(mAnimatorDuration);
        ObjectAnimator visToInvisX = ObjectAnimator.ofFloat(mAppsSelectView, "scaleX", 1, 0);
        visToInvisX.setDuration(mAnimatorDuration);
        ObjectAnimator visToInvisY = ObjectAnimator.ofFloat(mAppsSelectView, "scaleY", 1, 0);
        visToInvisY.setDuration(mAnimatorDuration);
        List<Animator> animList = new ArrayList<Animator>();
        animList.add(invisToVis);
        animList.add(visToInvisX);
        animList.add(visToInvisY);
        final AnimatorSet as = new AnimatorSet();
        as.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationStart(Animator animator) {
                Folder.this.setVisibility(View.VISIBLE);
                mRunningAnimatorSet = as;
                mRunningIsShow = false;
                mFolderName.setFocusable(false);
            }
            @Override
            public void onAnimationEnd(Animator animator) {
                mRunningAnimatorSet = null;
                mRunningIsShow = false;
                mAppsSelectView.setVisibility(View.INVISIBLE);
                Folder.this.setVisibility(View.VISIBLE);
                mFolderName.setFocusable(true);
                mFolderName.setFocusableInTouchMode(true);
                mIsEditingName = false;
            }
        });
        as.playTogether(animList);
        as.start();
    }
    private boolean contains(List<ShortcutInfo> list, ShortcutInfo info) {
        for(ShortcutInfo shortinfo : list) {
            if(shortinfo.intent.equals(info.intent)){
                return true;
            }
        }
        return false;
    }
	//deal the selected shortcut,first find the added and removed shortcuts,then deal them separately
    public void dealNewSelectedApps(ArrayList<ShortcutInfo> selectedShortcuts) {
        List<ShortcutInfo> currentShortcuts = new ArrayList(mInfo.contents);
        if(mInfo.isEditFolderInContents()) {
            currentShortcuts.remove(mInfo.getmEditFolderShortcutInfo());
        }
        List<ShortcutInfo> addedShortcuts = new ArrayList<ShortcutInfo>();
        List<ShortcutInfo> removedShortcuts = new ArrayList<ShortcutInfo>();
        for(ShortcutInfo select : selectedShortcuts) {
            if(!contains(currentShortcuts,select)) {
                addedShortcuts.add(select);
            }
        }
        for(ShortcutInfo current : currentShortcuts) {
            if(!contains(selectedShortcuts,current)){
                removedShortcuts.add(current);
            }
        }
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The apps amount added to folder is:" + addedShortcuts.size()
                        + ", detail is:" + addedShortcuts.toString());
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The apps amount removed from folder is:"
                        + removedShortcuts.size() + ", detail is:"
                        + removedShortcuts.toString());
        //deal the new added icon
        Workspace workspace = mLauncher.getWorkspace();
        ArrayList<ItemInfo> addItems = new ArrayList<ItemInfo>();
        for(ShortcutInfo shortcut : addedShortcuts) {
            ShortcutInfo clone = shortcut.clone();
            addItems.add(clone);
            // LauncherModel.getSbgworkspaceitems().remove(shortcut);
            mInfo.add(shortcut);
        }
        workspace.removeItemsViewByItemInfo(addItems);
        workspace.updateWorkspaceAfterDelItems(addItems);
        //if one screen has no icon after this function, then remove it
        workspace.checkAndRemoveEmptyCell();
        //deal the removed icons
        if(selectedShortcuts.size() == 0) {
            removedShortcuts.remove(0);
        }
        if(removedShortcuts.size() < 1) {
            return;
        }
        long container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
        List<ScreenPosition> emptyCellList = LauncherModel.findEmptyCells(removedShortcuts.size());
        Log.d(FolderAppsSelectView.LOG_TAG,
                "The amount of empty Cells found is " + emptyCellList.size()
                        + " ,detail is : " + emptyCellList.toString());
        if(emptyCellList == null || emptyCellList.size() == 0) {
            Log.d(FolderAppsSelectView.LOG_TAG,
                    "Have not the empty cell to place the apps in folder");
            Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
            return;
        }
        for(int i = 0; i < emptyCellList.size(); i++) {
            ScreenPosition pos = emptyCellList.get(i);
            ShortcutInfo shortcut = removedShortcuts.get(i);
            mInfo.remove(shortcut);
            //the empty position is in the new screen
            if(pos.s >= workspace.getChildCount()) {
                //if addEmptyScreen fail,then return
                if(!workspace.addEmptyScreenSync()) {
                    Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
                    break;
                }
            }
            //add the icon to the workspace
            CellLayout cell = (CellLayout) workspace.getChildAt(pos.s);
            shortcut.cellX = pos.x;
            shortcut.cellY = pos.y;
            shortcut.container = container;
            shortcut.screen = pos.s;
            View view = mLauncher.createShortcut(R.layout.application, cell,shortcut);
            workspace.addInScreen(view, container, pos.s, pos.x, pos.y, shortcut.spanX,
                    shortcut.spanY, false);
            cell.onDropChild(view);
            CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
            cell.getShortcutsAndWidgets().measureChild(view);
            LauncherModel.addOrMoveItemInDatabase(mLauncher, shortcut, container, pos.s, lp.cellX, lp.cellY);
            Log.d(FolderAppsSelectView.LOG_TAG, "The app:" + shortcut.title
                    + " has moved to workspace ,the pos is " + pos.toString());
        }
        if(emptyCellList.size() < removedShortcuts.size()) {
            Toast.makeText(mLauncher, getContext().getText(R.string.over_max_screen_count), Toast.LENGTH_SHORT).show();
        }
        //if one screen has no icon after this function, then remove it
        workspace.checkAndRemoveEmptyCell();
    }
    public FolderAppsSelectView getmAppsSelectView() {
        return mAppsSelectView;
    }

    /**
     * Minus folder title height to make drag out of Folder easier
     */
    @Override
    public void getHitRect(Rect outRect) {
        super.getHitRect(outRect);
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams)mFolderName.getLayoutParams();
        outRect.top += mFolderName.getHeight() + lp.bottomMargin;
        outRect.left = 0;
        outRect.right = mDisplaySize.x;
        outRect.bottom -= mContentList.get(0).getPaddingBottom();
        if (mDraggingToLeftEdge) {
            outRect.left = getLeft() + getResources().getDimensionPixelSize(R.dimen.scroll_zone);
        }
        if (mDraggingToRightEdge) {
            outRect.right = getRight() - getResources().getDimensionPixelSize(R.dimen.scroll_zone);
        }
    }

    final String HOR_LOG_TAG = "HorizFolder";
    public int getUnreadCount() {
        ShortcutAndWidgetContainer container = null;
        int unReadCount = 0;
        for (CellLayout mContent : mContentList) {
            container = mContent.getShortcutAndWidgetContainer();
            for (int i = 0, N = container.getChildCount(); i < N; i++) {
                View v = container.getChildAt(i);
                if (!(v instanceof BubbleTextView))
                    continue;
                BubbleTextView bubble = (BubbleTextView) v;
                unReadCount += bubble.getMessageNum();
            }
        }
        return unReadCount;
    }

    public int getNotificationCount() {
        ShortcutAndWidgetContainer container = null;
        int notificationCount = 0;
        for (CellLayout mContent : mContentList) {
            container = mContent.getShortcutAndWidgetContainer();
            for (int i = 0, N = container.getChildCount(); i < N; i++) {
                View v = container.getChildAt(i);
                if (!(v instanceof BubbleTextView))
                    continue;
                BubbleTextView bubble = (BubbleTextView) v;
                notificationCount += bubble.getNotificationCount();
            }
        }
        return notificationCount;

    }
    public int getMarkNumCount() {
        ShortcutAndWidgetContainer container = null;
        int markNumCount = 0;
        for (CellLayout mContent : mContentList) {
            container = mContent.getShortcutAndWidgetContainer();
            for (int i = 0, N = container.getChildCount(); i < N; i++) {
                View v = container.getChildAt(i);
                if (!(v instanceof BubbleTextView))
                    continue;
                BubbleTextView bubble = (BubbleTextView) v;
                /*!important*/
                bubble.getNotificationCount();
                markNumCount += bubble.getIconMarkNum();
            }
        }
        return markNumCount;
    }


    private void adjustContentListSize(int realNeedPageCount) {
        int currentCount = mContentList.size();
        int diff = Math.abs(currentCount - realNeedPageCount);
        for (int i = 0; i < diff; i++) {
            if (realNeedPageCount > currentCount) {
                addNewCellLayout();
            } else {
                mContentList.remove(mContentList.size() - 1);
            }
        }
        if (realNeedPageCount > currentCount) {
            updateFolderLayout(isSupportCardIcon());
        }
        if (diff != 0 || mPageIndicator.getMax() != realNeedPageCount) {
            for (int i = 1, count = mContentList.size(); i < count; i++) {
                mContentList.get(i).setHasChanged(true);
            }
            mFolderViewPager.setAdapter(mContentAdapter);
            // do not show indicator when page count is one
            mPageIndicator.setMax(realNeedPageCount == 1 ? 0 : realNeedPageCount);
            mPageIndicator.setCurrentPos(0);
            mPageIndicator.invalidate();
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // steal child's(ViewPager) touch event when animating
        return mState == STATE_ANIMATING ? true : super.onInterceptTouchEvent(ev);
    }

    private int getMaxItemsCountPerPage() {
        mMaxCountY = ConfigManager.getFolderMaxCountY();
        return mMaxCountX * mMaxCountY;
    }

    private CellLayout addNewCellLayout() {
        CellLayout cellLayout = (CellLayout) mInflater.inflate(R.layout.folder_page, null);
        cellLayout.setGridSize(0, 0);
        cellLayout.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
        cellLayout.setInvertIfRtl(true);
        mContentList.add(cellLayout);
        return cellLayout;
    }

    class FolderContentAdapter extends PagerAdapter {
        @Override
        public int getCount() {
            return mContentList.size();
        }

        @Override
        public boolean isViewFromObject(View arg0, Object arg1) {
            return arg0 == arg1;
        }

        @Override
        public int getItemPosition(Object object) {
            if (((CellLayout) object).hasChanged()) {
                ((CellLayout) object).setHasChanged(false);
                return POSITION_NONE;
            } else {
                return super.getItemPosition(object);
            }
        }

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            container.addView(mContentList.get(position));
            return mContentList.get(position);
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (position >= mContentList.size()) {
                container.removeView((View) object);
                return;
            }
            container.removeView(mContentList.get(position));
        }

        @Override
        public void setPrimaryItem(ViewGroup container, int position, Object object) {
            setContent((CellLayout) object);
        }
    };
    FolderSelectPager.OnPageChangeListener pageChangeListener = new FolderSelectPager.OnPageChangeListener() {
        @Override
        public void onPageSelected(int newPage) {
            // TODO indicator change
            mPageIndicator.setCurrentPos(newPage);
            mScrolling = false;
        }
        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            mScrolling = false;
        }
        @Override
        public void onPageScrollStateChanged(int state) {
        }
    };

    public void switchToPage(int page) {
        mFolderViewPager.setCurrentItem(page, true);
    }

    public void switchToPage(int page, boolean anim) {
        mFolderViewPager.setCurrentItem(page, anim);
    }
   
    public void updateFolderNameWithRemainedApp(ItemInfo item) {
        String originalFolderName = item.title + getResources().getString(R.string.folder_name_etc);
        String actualFolderName = mFolderName.getText().toString();
        if (originalFolderName.equals(actualFolderName)) {
            ShortcutInfo firstItem = (ShortcutInfo) mContentList.get(0).getChildAt(0, 0).getTag();
            String newFolderName = firstItem.title + getResources().getString(R.string.folder_name_etc);
            mInfo.setTitle(newFolderName);
            updateFolderName(newFolderName);
        }
    }

    Animator moveAnim = null;
    private void autoMoveIconByScroll(int srcPageIndex, int desPageIndex) {
        mScrolling = true;
        cancelMoveAnimation();
        final CellLayout srcPage = mContentList.get(srcPageIndex);
        final CellLayout desPage = mContentList.get(desPageIndex);
        View movedView = null;
        // scroll left
        if (srcPageIndex > desPageIndex) {
            for (int j = desPage.getCountY() - 1; j >= 0; j--) {
                for (int i = desPage.getCountX() - 1; i >= 0; i--) {
                    if ((movedView = desPage.getChildAt(i, j)) != null) {
                        moveAnim = ObjectAnimator.ofFloat(movedView, TRANSLATION_X, LauncherApplication.getScreenWidth() - movedView.getX() + 100);
                        break;
                    }
                }
                if (movedView != null) {
                    break;
                }
            }
        } else {
            // scroll right
            for (int j = 0; j < desPage.getCountY(); j++) {
                for (int i = 0; i < desPage.getCountX(); i++) {
                    if ((movedView = desPage.getChildAt(i, j)) != null) {
                        moveAnim = ObjectAnimator.ofFloat(movedView, TRANSLATION_X, -300);
                        break;
                    }
                }
                if (movedView != null) {
                    break;
                }
            }
        }
        if (movedView == null)
            return;
        final ItemInfo movedInfo = (ItemInfo) movedView.getTag();
        final View view = movedView;
        mReorderAlarm.cancelAlarm();
        moveAnim.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                view.setTranslationX(0);
                desPage.removeView(view);
                ViewParent parent = (view.getParent());
                if (parent != null) {
                    String title = "";
                    if (movedInfo != null) {
                        title = movedInfo.title.toString();
                    }
                    Log.e(HOR_LOG_TAG, "The icon:" + title
                            + ",has the parent when end on autoScroll,remove");
                    return;
                }
                CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
                int movedFromX = movedInfo.cellX;
                int movedFromY = movedInfo.cellY;
                lp.cellX = movedInfo.cellX = mEmptyCell[0];
                lp.cellY = movedInfo.cellY = mEmptyCell[1];
                mEmptyCell[0] = movedFromX;
                mEmptyCell[1] = movedFromY;
                boolean insert = false;
                srcPage.addViewToCellLayout(view, insert ? 0 : -1, (int) movedInfo.id, lp, true);
                // force to reorder
                // mReorderAlarm.cancelAlarm();
                // mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
                // mReorderAlarm.setAlarm(150);
            }
        });
        moveAnim.setDuration(300);
        moveAnim.start();
    }
    Comparator<ShortcutInfo> infoDownComp = new Comparator<ShortcutInfo>() {
        @Override
        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {
            // TODO Auto-generated method stub
            if (lhs.screen != rhs.screen) {
                return rhs.screen - lhs.screen;
            } else if (lhs.cellY != rhs.cellY) {
                return rhs.cellY - lhs.cellY;
            } else {
                return rhs.cellX - lhs.cellX;
            }
        }
    };
    //topwise zyf add for fixedfolder
    public LayoutInflater getLayoutInflater()
    {
    	return mInflater;
    }
    public void setLayoutInflater(LayoutInflater l)
    {
    	mInflater=l;
    }
    public int getMaxCountX()
    {
    	return mMaxCountX;
    }
    public void setMaxCountX(int i)
    {
    	mMaxCountX=i;
    }
    
    public int getMaxCountY()
    {
    	return mMaxCountY;
    }
    public void setMaxCountY(int i)
    {
    	mMaxCountY=i;
    }
    
    public int getMaxNumItems()
    {
    	return mMaxNumItems;
    }
    public void setMaxNumItems(int i)
    {
    	mMaxNumItems=i;
    }
   
    public InputMethodManager getInputMethodManager()
    {
    	return mInputMethodManager;
    }
    public void setInputMethodManager(InputMethodManager i)
    {
    	mInputMethodManager=i;
    }
	public void setExpandDuration(int i)
    {
    	 mExpandDuration=i;
    }
    public String getDefaultFolderName()
    {
    	return sDefaultFolderName;
    }
    public void setDefaultFolderName(String s)
    {
    	sDefaultFolderName=s;
    }
    public Point getDisplaySize()
    {
    	return mDisplaySize;
    }
    //topwise zyf add end

    //topwise zyf add for folderonline
    public boolean isOnlineShortcutInfo(Intent intent)
    {
        if(intent.getAction()!=null&&intent.getAction().equals("com.tpw.online"))
        {
        	return true;
        }
        return false;
    }
    //topwise zyf add end
}
